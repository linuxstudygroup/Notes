# BIOS & bootloader
## 从开机加电到执行main函数之前的过程
### 总结
* 主要参考了书《Linux内核的设计艺术》，早期系统16位模式，为了保持兼容性，系统初始启动的**实模式**也保持16位，**保护模式**为32位。实模式最大寻址范围为1MB，使用20根地址线。
* 本笔记主要是Linux 0.11下的执行过程，主要加载程序分为bootsec.s，setup.s，system.s(head.s)
*  [专栏总结] 专栏应该是比较新的Linux下的开机过程。电脑开机，第一个命令指向0xFFFF0进入实模式，实模式就是没有操作系统的模式，主要靠BIOS，同时BIOS初始化后会指向bootloader，bootloader会引导加载操作系统到内存，进入保护模式。
	* BIOS -> boot.img -> diskboot.img -> lzma_decompress.img 实模式到保护模式，建立分段分页，打开地址线 -> kernel.img 选择一个操作系统 -> 启动内核
### 基础概念
- [ ] 8086CPU有哪些寄存器
	* CPU内存寻址使用：CS(Code Segment Register)、IP(Intruction Pointer)两个寄存器，存的是绝对地址吧
	* 
### 开机
计算机一定要有程序才能运行，在开机上电的瞬间，硬件强行令CS=0xFFFF, IP=0x0，将CPU指向BIOS程序(0xFFFF0 Shadow RAM)。BIOS程序只有8KB，地址0xFE000 ~ 0xFFFFF.
### BIOS初始化
* 在0x0处加载256个4字节的中断向量表（0x0 ~ 0x003FF）
* 在0x3FF处加载256字节的BIOS数据区
* 在0x0E05B加载了8KB左右的中断服务程序
### 加载引导程序
* 加载之前已经执行了BIOS自检
* 发送int0x19中断，中断向量把CPU指向0x0E6F2，将硬盘第一扇区（引导程序）512字节的内容复制到0x07C00处
* 这个0x7C00位置是一个约定的定位，因为操作系统和BIOS是独立开发的，为了协调，就设置了这么一个位置。
### 执行引导程序bootsec.s
* 引导程序的主要工作就是规划内存
* 首先摆脱0x7C00，复制引导程序bootsec到新的位置0x90000，那么bootsec占据0些0x90000~0x90200
* 设置各个寄存器，CS(代码段寄存器)=ES(附加段寄存器)=SS(栈顶基址)=DS(数据寄存器)=0x90000,SP(栈顶偏移)=0xFF00,将栈顶指向0x9FF00
* 通过int 0x13中断复制4*256字节的setup.s程序到0x90200处
* 通过int 0x13中断复制240*256字节的system.s程序到0x10000处
* 确定根设备号
* 将CPU指向0x90200
### 执行setup.s
* 这一过程开始向32位模式转变
* 关中断并将system程序已到0x00000处，此时BIOS的中断向量及中断服务程序已被覆盖
* 设置中断描述符表(IDTR)和全局描述符表(GDTR)(似乎是在setup.s程序段里面)
* 打开A20，实现32位寻址（汇编）
* 对可编程的中断控制器重新编程(?)
* 将CR0寄存器的保护模式使能标志设置位1，标志系统进入了保护模式
* 根据GDT决定下一步指向，jmpi 0,8，0是段内偏移，8是段选择符。8->1000,末尾是特级权，也就是00，即内核特级权，第3位0代表GDT，1代表描述符表第一行。通过GDTR找到GDT入口地址，从而找到CPU下一执行入口0x00000000偏移为0
### 执行head.s
* head.s程序执行的代码会把自己覆盖
* 设置内核堆栈
* 重新设置中断描述符表IDT和全局描述符表GDT，因为之前的setup.s在后面会被覆盖
* 设置页目录，页表
* 将main程序的入口地址压入堆栈中
* 内存规划：
	* 0x00000 - 0x01000 - 0x02000 - 0x03000- 0x04000 - 0x05000 - 0x05400 - 0x054b8 - 0x05cb8 - 0x064b8
	* 页目录表(4KB) - 页表0(4KB) -  页表1(4KB) - 页表2(4KB) - 页表3(4KB) - 缓冲区(1kb) - 剩余 - 中断描述符表(2KB) - 全局描述符表(2KB)
### （待续）