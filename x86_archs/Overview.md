# IA32芯片架构

现代计算机的架构如下图所示

```txt

-----------------
|               | =======================+
|   processor   | ===============+       |
|               | =======+       |       |
-----------------        |       |       |
                         |       |       |
                         |       |       |
-----------------        |       |       |
|               | =======|=======|=======+
|    System     | =======|=======+       |
|    Memory     | =======+       |       |
|               |        |       |       |
----------------         |       |       |
                         |       |       |
                         |       |       |
-----------------        |       |       |
|               | =======|=======|=======+
| Input Device  | =======|=======+       |
|               | =======+       |       |
-----------------        |       |       |
                         |       |       |
                         |       |       |
-----------------        |       |       |
|               | =======|=======|=======+
| Output Device | =======|=======+
|               | =======+
-----------------        
```

这里面，处理器负责运算和控制计算机中其他部件。其他的部件包括了内存，输入设备和输出设备。

在教科书上，一般说现在计算机包括了五个部件：
* 运算器
* 控制器
* 内存
* 输入设备
* 输出设备

运算器和控制器一般集成在了处理器的内部了，也就变成了上面的那个图。

处理器和其他部件之间通过三个总线进行连接：
* 控制总线
* 地址总线
* 数据总线

**控制总线** 主要用来传送 **控制** 信号和时序信号。  **控制** 信号中，有的是微处理器送往存储器和输入输出设备接口电路的，比如：读/写信号、片选信号、中断响应信号等；也有是其它部件反馈给CPU的，比如：中断申请信号、复位信号、**总线** 请求信号、设备就绪信号等[reference](https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF)

数据总线负责处理器和其他部件的数据传输。

地址总线负责传输数据地址。注意，这里所有的其他部件共用同一条地址总线，其实也就规定了，所有的部件都公用同一个物理地址池。

## 处理器结构
处理器（CPU）主要包含了以下的几个部件：
* 控制单元
* 执行单元
* 寄存器
* 运算标志（实际上也是寄存器）


```txt
                                                ------------                                                                                       
-------------       -------------       +-----> | Register |        
|           |       |           | <-----+       ------------
| Ctrl Unit | <===> | Exec Unit |
|           |       |           | <-----+       ------------
-------------       -------------       +-----> |  Flags   |
                                                ------------                                     
```

### 控制单元

控制单元是一个处理器的心脏。它会控制处理器什么时候该干什么事情。控制单元主要会做以下的四种事情：

1. 从内存取下一条指令
2. 解码指令
3. 从内存取数据
4. 存储运算结果

### 执行单元

执行单元是处理器中负责进行运算的部件。一个处理器中实际上可以包含多个执行单元。

一个执行单元中又包含了多个逻辑运算单元（Arithmetic Logic Units， ALU）。

ALU也分多个种类，有的负责简单的整数运算，有的负责复数运算，有的负责浮点数运算，具体的一个处理器的执行单元包含那些ALU的看处理器的实现。

### 寄存器

处理器的大部分指令都需要处理数据，但是CPU从内存中读写数据的速度实在是慢，这就限制住了CPU的执行速度。所以在处理器内部就引入了一些特殊的存储单元：寄存器。

IA32架构中的寄存器可以分为以下六类：

* 通用寄存器：8个32位寄存器
* 段寄存器： 6个16位寄存器
* 指令指针寄存器： 1个32位寄存器
* 浮点数寄存器： 8个80位寄存器
* 控制寄存器： 5个32位寄存器
* 调试寄存器： 8个32位寄存器

#### 通用寄存器

通用寄存器是用来存储处理器需要用到的临时数据的。现在的通用存储器是从8086时代演化过来的，都具有前向兼容性。

下面是IA32架构中的通用寄存器表，后面列出了他们最常见的用法：

| 寄存器名 | 描述 |
| --- | --- |
| EAX | 累加器，保存运算结果 |
| EBX | 指向数据的地址的指针 |
| ECX | 用于循环过程中的计数器 |
| EDX | 指向I/O地址的指针 |
| EDI | 目的地址指针 |
| ESI | 源地址指针 |
| ESP | 堆栈指针 |
| EBP | 指向数据基地址指针 |

其中32位的EAX、EBX、ECX、EDX寄存器也有对应的寄存器名称指向它的低16和8位。

虽然寄存器的名称不同，但是AX， AH， AL都是指向EAX的某些个位的。他们实际上是同一个寄存器。

```txt
31               15       7        0
|                EAX               |
|                |        AX       |
|                |   AH   |   AL   |  
```


#### 段寄存器

段寄存器是给内存寻址使用的，IA32架构有以下三种内存模型，他们对应了不同的寻址模式：

* 平坦内存模型
* 段内存模型
* 实地址内存模型

说是三种内存模型，实际上是三种寻址模式。

在平坦内存模型下面，系统中所有的内存被看作是在同一个线性空间下的。所有的数据，堆栈，指令都被认为是放在同一个地址空间下，这个地址空间又被成为线性地址。这个时候所有的段寄存器都会被初始化成同样的值。

段内存模型会把内存划分成一块一块的段，段寄存器指向段对应的首地址。不同的段对应了不同用途的数据。比如代码段对应的就是指令数据，堆栈段对应的是堆栈数据。

实地址内存模式是和8086模式保持兼容性的一种内存模型。在这个模式下，所有的段寄存器都被设置成0。程序不能改变这些段寄存器的值。所有的指令、数据都存储在同一个线性地址空间下。

段寄存器是16位的寄存器，IA32架构有以下的6个段寄存器：

| 寄存器名 | 描述 |
| --- | --- |
| CS | 代码段寄存器 |
| DS | 数据段寄存器 |
| SS | 堆栈段寄存器 |
| ES | 附加段寄存器 |
| FS | 附加段寄存器 |
| GS | 附加段寄存器 |

其中，代码段寄存器CS指向的是指令所存储的那一段内存。

DS、ES、FS、GS四个段寄存器都是指向数据段的寄存器。

堆栈段寄存器SS用于指向堆栈的栈地址。

#### 指令指针寄存器

指令指针寄存器（EIP），也被称作程序计数器。这个寄存器里面存放了CPU要执行的下一条指令的地址。程序不能直接将内存地址mov到这个寄存器里面。如果想要修改这个寄存器的值，需要使用jump指令的指令。

在平坦内存模型下，EIP存储的就是下一条指令的线性地址。

而在段内存模型下，EIP需要和代码段寄存器CS配合使用，得到下一条指令在内存中的地址。

#### 控制寄存器

IA32架构中有5个控制寄存器。这些寄存器决定了处理器运行的模式。下表是这五个寄存器的描述：

| 寄存器名 | 描述 |
| --- | --- |
| CR0 | 控制处理器模式和状态的标志位寄存器 |
| CR1 | 留待后用 |
| CR2 | 内存页错误信息寄存器 |
| CR3 | 内存页目录信息寄存器 |
| CR4 | 使能处理器特性的标志位 |

控制寄存器的也不能直接被访问，但是控制寄存器的值可以被mov到通用寄存器中。一旦控制寄存器的值被赋值到通用寄存器中，程序就可以对这些标志位进行检查，以获取处理器的运行状态。

如果想要更改控制器存器的值，也需要先把值放进通用寄存器中，然后在把通用寄存器中的值复制到控制寄存器中去。

系统级的程序需要经常访问控制寄存器，而应用级的程序并不需要经常访问控制寄存器。

#### 标志位寄存器

对于处理器执行的每一条指令来说，必须有一个地方存储运算结果，也就是说我们必须能从某个地方知道指令执行的成功与否，有没有溢出，运算结果是不是等于0等信息。标志位寄存器就是这么一个存储指令执行结果的地方。

标志位寄存器对于汇编语言来说非常的重要。比如说我们要知道一个减法操作的结果是不是为负数，就可以从标志位寄存器中的某一位进行判断。

IA32架构处理器用了一个32位的寄存器来存储状态、控制和系统的标志。这个寄存器的名字叫做EFLAGS。现在，这个寄存器中有17位用于标志上面描述的信息，其他的位留待后用。

标志位寄存器中的标志可以归类为以下的三组：
* 状态标志
* 控制标志
* 系统标志


##### 状态标志

状态标志包括以下6个：

| 标志位名 | 位置 | 全名 |
| --- | --- | --- |
| CF | 0 | 进位标志（carry flag） |
| PF | 2 | 奇偶标志（parity flag） |
| AF | 4 | 辅助标志（adjust flag） |
| ZF | 6 | 零标志（zero flag） |
| SF | 7 | 正负标志（sign flag） |
| OF | 11 | 溢出标志（overflow flag） |

* CF： 计算结果有进位或者有借位，该位置1
* PF： 如果运算结果中1的个数位偶数，该位为1，可以用于奇偶校验
* AF： 辅助标志为可以用于BCD码计算，因为BCD码是4位的，所以如果计算结果的第四位发生了进位或者借位，辅助标志位被置1
* ZF： 计算结果为0，该位置1
* SF： 计算结果为负数的时候，该位置1
* OF： 计算结果溢出，该位置1。

溢出：存储计算结果需要的位数超出寄存器能存储的位数的时候称为溢出

##### 控制标志

控制标志位只有1个DF。

DF全称是direction flag。一般在批量内存处理的时候才会被用到。这一位等于0的时候，每mov一次内存，对应的指针寄存器会增加。这一位等于1的时候，指针寄存器会减小。后面谈到具体的指令的时候提到这个寄存器，但一般不会怎么使用到。

##### 系统标志位

系统标志位用于标志系统的运行状态，有以下这些：

| 标志位名 | 位置 | 全名 |
| --- | --- | --- |
| TF | 8 | 追踪标志（trap flag） |
| IF | 9 | 中断使能标志（interrupt enable flag） |
| IOPL | 12 and 13 | I/O特权级标志位（I/O privilege level flag） |
| NT | 14 | 嵌套任务标志（nested task flag） |
| RF | 16 | 恢复标志（resume flag） |
| VM | 17 | 虚拟8086模式标志（virtual-8086 mode flag） |
| AC | 18 | 内存对齐检查标志（alignment check flag） |
| VIF | 19 | 虚拟中断标志 |
| VIP | 20 | 虚拟中断挂起标志 |
| ID | 21 | ID标志 |

* TF：该位置1时，CPU为单步调试模式
* IF： 该位置1是，CPU相应可屏蔽中断
* IOPL： 如果当前IO操作的特权级小于这两位的时候，这个IO操作才会被执行，否则会触发一个保护中断
* NF： 嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下： 当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；当NT=1，通过任务转换实现中断返回。
* RF： 恢复标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。
* VM： 该位为1时，处理器运行在虚拟8086模式
* AC： 该位为1时，使用内存对齐检查功能
* VIF： 该位是中断标志位的镜像，当处理器运行在虚拟模式下的时候使用这个标志位，通常这个标志位是和VIP配合使用的
* VIP： 当CPU运行在虚拟模式下时，该表示位为1表示有中断挂起。
* ID： 该位为1表示处理器支持CPUID这个指令。
